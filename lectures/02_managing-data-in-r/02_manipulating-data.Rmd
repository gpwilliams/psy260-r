---
title: "Managing Data in R"
subtitle: "Data Wrangling in R"
author: "Glenn Williams"
institute: "University of Sunderland"
date: "2021-10-27 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  df_print: paged
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
set.seed(100)
library(tidyverse)
library(here)

options(tibble.print_min = 4)
```

```{r functions, include = FALSE}
colorise <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
      x)
  } else x
}
```

# Loading our Cleaned Data

Let's load up a data set.

Remember, `read_csv()` takes one argument: where is your data!

```{r load-data-a}
data_a <- read_csv(here("data", "factorial_data_a.csv"))
```

The rest of our data is in a second table. Let's load this in too.

```{r load-data-b, message = FALSE}
data_b <- read_csv(here("data", "factorial_data_b.csv"))
```

---
# Tidy Data

Our data is in a tidy/long format.

```{r tidy-data-1, echo = FALSE, out.width = 700, fig.align = "center", fig.cap="Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst"}
knitr::include_graphics(c(
   "../../img/allison-horst_illustrations/tidy-data/tidydata_1.jpg"
))
```

---
# Why Use Tidy Data?

This makes cleaning, summarising, plotting, and modelling easier!

```{r tidy-data-3, echo = FALSE, out.width = 700, fig.align = "center", fig.cap="Illustrations from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst"}
knitr::include_graphics(c(
   "../../img/allison-horst_illustrations/tidy-data/tidydata_3.jpg"
))
```

---
# Common Data Processing Tasks

The most common data manipulation problems can be handled effectively by `dplyr`, a package within the tidyverse:

**One Table**:

- `filter()`: filters our data to keep observations that only meet given conditions.

- `select()`: selects a subset of columns in our table.

- `mutate()`: changes our data in some way by the instructions you provide.

**Multiple Tables**:

- `bind_rows()`: adds rows from one data frame to another (if they have the same columns).

- `bind_cols()`: adds columns to one data frame from another (if they have the same number of rows).

---
# Filter

```{r dplyr-filter, echo = FALSE, out.width = 700, fig.align = "center", fig.cap="Artwork by @allison_horst"}
knitr::include_graphics(c(
   "../../img/allison-horst_illustrations/general/dplyr_filter.jpg"
))
```

---
# Filter

Let's say we want to keep only observations from our first participant. This might be useful for exploring data individually.

```{r keep-subject-one}
filter(data_a, subj_id == 4)
```

We have only 40 observations now, all from subject 4.

---
# Combining Filter Conditions

Maybe we want to check if subject 4 has any missing data in the variable Y. How might we do this? 

We could apply two separate filters, or combine our filter conditions using logical operations.

```{r subj-one-na}
filter(data_a, subj_id == 4 & is.na(Y))
```

Note that **NAs are special in R**, so we have to use is.na() which checks for any NA values explicitly, rather than Y == NA.

*It looks like subject 4 has 1 missing response!*

---
# Select

Select works by defining the names of **columns you'd like to keep**, and in what order!

```{r dplyr-select, echo = FALSE, out.width = 500, fig.align = "center", fig.cap="Artwork by @allison_horst"}
knitr::include_graphics(c(
   "../../img/allison-horst_illustrations/general/dplyr_select.png"
))
```

---
# Select

Imagine we only want to **keep the subject_id** column.

```{r select-keep}
select(data_a, subj_id)
```

---
# Select

Imagine we want to **remove the list_id column**. We simply put a minus before the column name.

```{r select-out}
select(data_a, -list_id)
```

---
# Select

Maybe we'd like to **reorganise our columns so columns A and B come first and everything else after**. Select A and B, and then everything else using `everything()`; a dplyr helper function.

```{r select-reorder}
select(data_a, A, B, everything())
```

---
# Muatate

What if we want to **change our data**? Use `mutate()`.

```{r dplyr-mutate, echo = FALSE, out.width = 500, fig.align = "center", fig.cap="Artwork by @allison_horst"}
knitr::include_graphics(c(
   "../../img/allison-horst_illustrations/general/dplyr_mutate.png"
))
```

---
# Mutate

With mutate we can **change the data within columns**, or **create new columns** of data entirely.

Let's create a new column. This will combine the text in columns A and B. We will use `paste()` to do this. The argument `sep = "+"` will add a plus between the entries.

```{r mutate-create}
mutate(data_a, AB = paste(A, B, sep = "+"))
```

---
# Mutate

Perhaps instead we want to **change the data in a column in place**? Let's get the natural logarithm on the scores in Y.

```{r mutate-change}
mutate(data_a, Y = log(Y))
```

---
# Converting Values Conditionally

- **Conditionals** are statements we give the computer where we want it to do something **only if a condition is met**.

- Using the tidyverse, we have a nice way to set these up using the function `case_when()`. It looks like this:

```{r case-when-example, eval = FALSE}
case_when(
  data == value ~ replacement,
  TRUE ~ data
)
```

- We give this function an argument relating to what **case** we care about (e.g. when the data is equal to a value).

- To the right of the `~` we tell R what the value should be in this case.

- We finally set a default value (`TRUE`), i.e. all other cases. Here, we tell R to just use the original value in the data.

---
# Mutate

- `case_when()` can work on individual vectors of data, or on columns within a data frame if we combine it with the `mutate()` function.

- Here, we'll we'll recode an item in the item_id column. Let's change item 1 to item 20.

```{r mutate-case-when}
mutate(
  data_a, 
  item_id = case_when(
    item_id == 1 ~ 20,
    TRUE ~ item_id
  )
)
```

---
# Bind Rows

Our data is stored in two separate tables. Let's join them together using `bind_rows()`.

```{r bind-rows}
# bind it together
combined_data <- bind_rows(data_a, data_b)

# print it out
combined_data
```
Now our data has a total of 2400 rows. We've combined the tables together!

---
# Bind Cols

We can bind columns together in a similar way.

- First, we'll extract the columns A and B, both only having the first 4 rows of our data each. 

- Then to show how the function works, we'll bind these objects together using `bind_cols()`.

```{r bind-cols}
# get our data
col_a <- combined_data[1:4, "A"]
col_b <- combined_data[1:4, "B"]

# bind it together
bind_cols(col_a, col_b)
```

---
# Recap

We know...

- What **tidy data** is, and why we want our data to be in this format.

- How to **manipulate one-table data** for cleaning and preparation for analysis/graphing, including:

    - How to **filter** observations out of our data set.

    - How to **select** particular columns in our data set.

    - How to **mutate** or modify existing data and even create new columns of data.

- How to bind rows and columns together from **multiple tables**.
